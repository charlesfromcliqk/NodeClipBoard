<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Copy Count - Node Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            overflow-x: auto;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
        }

        .header {
            background: white;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 12px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 20px;
        }

        .filename-section {
            margin-bottom: 12px;
        }

        .filename-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
            transition: border-color 0.2s;
        }

        .filename-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .save-info {
            font-size: 11px;
            color: #666;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .stats {
            display: flex;
            gap: 16px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .stat {
            background: #f7f7f7;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
        }

        .stat-label {
            color: #666;
            font-size: 10px;
            margin-bottom: 2px;
        }

        .stat-value {
            color: #333;
            font-weight: 600;
            font-size: 16px;
        }

        .controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .btn-secondary {
            background: #48bb78;
            color: white;
        }

        .btn-secondary:hover {
            background: #38a169;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .btn-add {
            background: #ed8936;
            color: white;
        }

        .btn-add:hover {
            background: #dd6b20;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .btn-cycle {
            background: #48bb78;
            color: white;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
        }

        .btn-cycle:hover {
            background: #38a169;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .nodes-container {
            position: relative;
            min-height: 400px;
            padding: 20px;
            overflow: visible;
        }

        .node {
            position: absolute;
            background: white;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            min-width: 280px;
            cursor: move;
            transition: box-shadow 0.2s;
            z-index: 10;
        }

        .node:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .node.dragging {
            opacity: 0.7;
            z-index: 1000;
        }

        .node.triple-node {
            border: 2px solid #9f7aea;
        }

        .node.magnode {
            border: 2px solid #f6ad55;
        }

        .node.instance-node {
            border: 2px solid #4299e1;
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e2e8f0;
        }

        .node-connectors {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .node-connectors-in {
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }

        .node-connectors-out {
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }

        .connector {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #667eea;
            background: white;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .connector:hover {
            background: #667eea;
            transform: scale(1.2);
        }

        .connector.connected {
            background: #48bb78;
            border-color: #38a169;
        }

        .connector.skipped {
            background: #e53e3e;
            border-color: #c53030;
        }

        .connector.connecting {
            background: #ed8936;
            border-color: #dd6b20;
            transform: scale(1.5);
            box-shadow: 0 0 10px rgba(237, 137, 54, 0.8);
        }

        .connector.active {
            background: #48bb78;
            border-color: #38a169;
        }

        .connector-in {
            left: -12px;
        }

        .connector-out {
            right: -12px;
        }

        .connector::after {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #667eea;
        }

        .connector.connected::after {
            background: white;
        }

        .connector-in.triple {
            margin: 4px 0;
        }

        .node-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .blurb-title {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 12px;
            font-family: inherit;
            font-weight: 600;
            transition: border-color 0.2s;
        }

        .blurb-title:focus {
            outline: none;
            border-color: #667eea;
        }

        .blurb-textarea {
            width: 100%;
            min-height: 60px;
            min-width: 200px;
            padding: 6px 8px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 12px;
            font-family: inherit;
            resize: both;
            transition: border-color 0.2s;
            line-height: 1.4;
        }

        .blurb-textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .node-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e2e8f0;
        }

        .copy-count {
            background: #f7f7f7;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            color: #666;
        }

        .btn-copy {
            background: #4299e1;
            color: white;
            padding: 6px 12px;
            font-size: 11px;
            min-width: 60px;
        }

        .btn-copy:hover {
            background: #3182ce;
        }

        .btn-copy.copied {
            background: #48bb78;
        }

        .btn-copy.last-copied {
            background: #e53e3e;
        }

        .btn-copy.last-copied:hover {
            background: #c53030;
        }

        .btn-delete {
            background: #fc8181;
            color: white;
            padding: 4px 8px;
            font-size: 10px;
            min-width: 50px;
        }

        .btn-delete:hover {
            background: #f56565;
        }

        .btn-separate {
            background: #9f7aea;
            color: white;
            padding: 6px 12px;
            font-size: 11px;
            min-width: 100px;
        }

        .btn-separate:hover {
            background: #805ad5;
        }

        .btn-add-input {
            background: #f6ad55;
            color: white;
            padding: 4px 8px;
            font-size: 10px;
            margin-top: 4px;
        }

        .btn-add-input:hover {
            background: #ed8936;
        }

        .connection-line {
            position: absolute;
            pointer-events: none;
            z-index: 1;
            stroke: white;
            stroke-width: 4;
            fill: none;
            stroke-opacity: 1;
        }

        .connection-line.connecting {
            stroke: #ed8936;
            stroke-dasharray: 5,5;
            stroke-width: 4;
        }

        .connection-line.skipped {
            stroke: #e53e3e;
            stroke-width: 4;
            opacity: 0.8;
        }

        .connection-line.active {
            stroke: #48bb78;
            stroke-width: 5;
        }

        .chain-copy-button {
            position: absolute;
            background: #9f7aea;
            color: white;
            padding: 8px 16px;
            font-size: 12px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 100;
            transition: all 0.2s;
        }

        .chain-copy-button:hover {
            background: #805ad5;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .hidden {
            display: none;
        }

        .empty-state {
            background: white;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            color: #666;
        }

        .empty-state p {
            margin-bottom: 20px;
        }

        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Copy Count - Node Manager</h1>
            <div class="filename-section">
                <input type="text" id="filenameInput" class="filename-input" placeholder="Enter filename for save (optional)" value="">
                <div class="save-info">
                    ðŸ’¡ <strong>Save:</strong> Uses default filename â€¢ <strong>Save As:</strong> Choose location and filename (modern browsers only)
                </div>
            </div>
            <div class="filename-section">
                <input type="text" id="concatenationInput" class="filename-input" placeholder="Text to prepend when copying (cleared after copy)" value="">
                <div class="save-info" style="font-size: 10px;">
                    ðŸ’¡ Text in this box will be prepended to any copied node content
                </div>
            </div>
            <div class="stats">
                <button class="btn-cycle" onclick="cycleCopy()">Cycle</button>
                <div class="stat">
                    <div class="stat-label">Total Copies</div>
                    <div class="stat-value" id="totalCount">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Nodes</div>
                    <div class="stat-value" id="nodeCount">0</div>
                </div>
            </div>
            <div class="controls">
                <button class="btn-add" onclick="addNode()">+ Add Node</button>
                <button class="btn-add" onclick="addTripleNode()" style="background: #9f7aea;">+ Add Triple Node</button>
                <button class="btn-add" onclick="addMagnode()" style="background: #f6ad55;">+ Add Magnode</button>
                <button class="btn-add" onclick="addInstanceNode()" style="background: #4299e1;">+ Add Instance Node</button>
                <button class="btn-add" onclick="addStage1Generator()" style="background: #0077b5;">+ Stage 1 Generator</button>
                <button class="btn-add" onclick="addStage2Generator()" style="background: #0077b5;">+ Stage 2 Generator</button>
                <button class="btn-add" onclick="addStage3Generator()" style="background: #0077b5;">+ Stage 3 Generator</button>
                <button class="btn-primary" onclick="saveData()">Save</button>
                <button class="btn-primary" onclick="saveAsData()">Save As</button>
                <button class="btn-secondary" onclick="loadData()">Load</button>
                <input type="file" id="fileInput" accept=".json" class="hidden" onchange="handleFileSelect(event)">
            </div>
        </div>

        <div class="nodes-container" id="nodesContainer">
            <svg id="connectionsSvg"></svg>
            <div class="empty-state" id="emptyState">
                <p>No nodes yet. Click "Add Node" to get started!</p>
                <p style="font-size: 12px; color: #999;">Drag a node's left connector (in) onto another node's right connector (out) to connect them.</p>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // STATE MANAGEMENT
        // ============================================================================
        // ============================================================================
        // OOP CLASS STRUCTURE
        // ============================================================================
        
        class NodeBase {
            constructor(id, type, x, y, options = {}) {
                console.log(`[NodeBase.constructor] Creating ${type} node with id: ${id}`);
                this.id = id;
                this.type = type;
                this.x = x;
                this.y = y;
                this.text = options.text || '';
                this.copyCount = 0;
                this.title = options.title || '';
                this.allowSplit = options.allowSplit !== undefined ? options.allowSplit : true;
            }
            
            getText(context) {
                console.log(`[NodeBase.getText] Node ${this.id} (${this.type}) - text: "${this.text}"`);
                const result = this.normalize(this.text);
                console.log(`[NodeBase.getText] Node ${this.id} returning: "${result}"`);
                return result;
            }
            
            normalize(text) {
                return text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            }
        }
        
        class RegularNode extends NodeBase {
            constructor(id, x, y, options) {
                super(id, 'regular', x, y, options);
            }
        }
        
        class TripleNode extends NodeBase {
            constructor(id, x, y, options) {
                super(id, 'triple', x, y, { ...options, allowSplit: false });
                this.skipIndex = 0;
                console.log(`[TripleNode.constructor] Created triple node ${id} with skipIndex: ${this.skipIndex}`);
            }
            
            getText(context) {
                console.log(`[TripleNode.getText] START - Node ${this.id}, skipIndex: ${this.skipIndex}, skipCycling: ${context.skipCycling}`);
                const inputs = context.connectionManager.getNodeInputs(this.id);
                console.log(`[TripleNode.getText] Node ${this.id} inputs:`, inputs);
                const texts = [];
                for (let i = 0; i < 3; i++) {
                    console.log(`[TripleNode.getText] Checking input ${i}: skipIndex=${this.skipIndex}, hasInput=${inputs[i]?.length > 0}`);
                    if (i !== this.skipIndex && inputs[i]?.length > 0) {
                        const sourceNode = context.nodeManager.find(inputs[i][0]);
                        console.log(`[TripleNode.getText] Input ${i} source node:`, sourceNode?.id, sourceNode?.text);
                        if (sourceNode) {
                            const normalized = this.normalize(sourceNode.text);
                            texts.push(normalized);
                            console.log(`[TripleNode.getText] Added text from input ${i}: "${normalized}"`);
                        }
                    }
                }
                if (!context.skipCycling) {
                    const oldSkipIndex = this.skipIndex;
                    this.skipIndex = (this.skipIndex + 1) % 3;
                    console.log(`[TripleNode.getText] Cycled skipIndex from ${oldSkipIndex} to ${this.skipIndex}`);
                }
                const result = texts.join('\n');
                console.log(`[TripleNode.getText] END - Node ${this.id} returning: "${result}"`);
                return result;
            }
        }
        
        class MagnodeNode extends NodeBase {
            constructor(id, x, y, options) {
                super(id, 'magnode', x, y, { ...options, allowSplit: false });
                this.inputCount = 2;
                this.activeIndex = 0;
                console.log(`[MagnodeNode.constructor] Created magnode ${id} with inputCount: ${this.inputCount}, activeIndex: ${this.activeIndex}`);
            }
            
            getText(context) {
                console.log(`[MagnodeNode.getText] START - Node ${this.id}`);
                console.log(`[MagnodeNode.getText] Current activeIndex: ${this.activeIndex}`);
                console.log(`[MagnodeNode.getText] Context:`, {
                    skipCycling: context.skipCycling,
                    skipMagnodeChain: context.skipMagnodeChain,
                    magnodesToCycle: context.magnodesToCycle
                });
                
                const inputs = context.connectionManager.getMagnodeInputs(this.id);
                console.log(`[MagnodeNode.getText] All inputs:`, inputs);
                console.log(`[MagnodeNode.getText] Input count: ${this.inputCount}`);
                
                const activeIndex = this.activeIndex || 0;
                console.log(`[MagnodeNode.getText] Using activeIndex: ${activeIndex}`);
                console.log(`[MagnodeNode.getText] inputs[${activeIndex}]:`, inputs[activeIndex]);
                
                if (!inputs[activeIndex]?.length) {
                    console.log(`[MagnodeNode.getText] No input at activeIndex ${activeIndex}, returning empty`);
                    return '';
                }
                
                const sourceNodeId = inputs[activeIndex][0];
                console.log(`[MagnodeNode.getText] Source node ID: ${sourceNodeId}`);
                const sourceNode = context.nodeManager.find(sourceNodeId);
                console.log(`[MagnodeNode.getText] Source node found:`, sourceNode ? {id: sourceNode.id, text: sourceNode.text?.substring(0, 50)} : 'NOT FOUND');
                
                if (!sourceNode) {
                    console.log(`[MagnodeNode.getText] Source node not found, returning empty`);
                    return '';
                }
                
                const hasIncoming = context.connectionManager.hasIncoming(this.id);
                const isInChain = context.magnodesToCycle !== null;
                console.log(`[MagnodeNode.getText] hasIncoming: ${hasIncoming}, isInChain: ${isInChain}`);
                
                if (hasIncoming || isInChain) {
                    console.log(`[MagnodeNode.getText] Using chain context - returning active input text`);
                    if (context.magnodesToCycle) {
                        const wasInSet = context.magnodesToCycle.has(this.id);
                        context.magnodesToCycle.add(this.id);
                        console.log(`[MagnodeNode.getText] Added to magnodesToCycle (was already in set: ${wasInSet})`);
                    }
                    const result = this.normalize(sourceNode.text);
                    console.log(`[MagnodeNode.getText] END - Returning normalized text: "${result.substring(0, 100)}..."`);
                    return result;
                } else {
                    console.log(`[MagnodeNode.getText] Using standalone context - building chain from source`);
                    const chainText = context.textExtractor.getChainText(sourceNodeId, context);
                    console.log(`[MagnodeNode.getText] Chain text result: "${chainText.substring(0, 100)}..."`);
                    if (!context.skipCycling && this.inputCount > 1) {
                        const oldIndex = this.activeIndex;
                        this.activeIndex = (activeIndex + 1) % this.inputCount;
                        console.log(`[MagnodeNode.getText] Cycled activeIndex from ${oldIndex} to ${this.activeIndex}`);
                    }
                    console.log(`[MagnodeNode.getText] END - Returning chain text`);
                    return chainText;
                }
            }
            
            cycle() {
                console.log(`[MagnodeNode.cycle] START - Node ${this.id}`);
                console.log(`[MagnodeNode.cycle] Current activeIndex: ${this.activeIndex}, inputCount: ${this.inputCount}`);
                if (this.inputCount > 1) {
                    const oldIndex = this.activeIndex;
                    this.activeIndex = ((this.activeIndex || 0) + 1) % this.inputCount;
                    console.log(`[MagnodeNode.cycle] Cycled from ${oldIndex} to ${this.activeIndex}`);
                } else {
                    console.log(`[MagnodeNode.cycle] Not cycling - only ${this.inputCount} input(s)`);
                }
                console.log(`[MagnodeNode.cycle] END - New activeIndex: ${this.activeIndex}`);
            }
        }
        
        class InstanceNode extends NodeBase {
            constructor(id, x, y, options) {
                super(id, 'instance', x, y, { ...options, allowSplit: false });
                this.inputCount = 2;
                console.log(`[InstanceNode.constructor] Created instance node ${id}`);
            }
            
            getText(context) {
                console.log(`[InstanceNode.getText] START - Node ${this.id}`);
                const inputs = context.connectionManager.getInstanceInputs(this.id);
                console.log(`[InstanceNode.getText] Inputs:`, inputs);
                console.log(`[InstanceNode.getText] Content reference input (1):`, inputs[1]);
                
                if (!inputs[1]?.length) {
                    console.log(`[InstanceNode.getText] No content reference, returning empty`);
                    return '';
                }
                
                const sourceNode = context.nodeManager.find(inputs[1][0]);
                console.log(`[InstanceNode.getText] Source node:`, sourceNode ? {id: sourceNode.id, type: sourceNode.type} : 'NOT FOUND');
                
                if (!sourceNode) {
                    console.log(`[InstanceNode.getText] Source node not found, returning empty`);
                    return '';
                }
                
                if (sourceNode.type === 'magnode') {
                    console.log(`[InstanceNode.getText] Source is magnode, getting active input`);
                    const magnodeInputs = context.connectionManager.getMagnodeInputs(sourceNode.id);
                    const activeIndex = sourceNode.activeIndex || 0;
                    console.log(`[InstanceNode.getText] Magnode activeIndex: ${activeIndex}, inputs:`, magnodeInputs);
                    
                    if (magnodeInputs[activeIndex]?.length > 0) {
                        const activeInputNode = context.nodeManager.find(magnodeInputs[activeIndex][0]);
                        console.log(`[InstanceNode.getText] Active input node:`, activeInputNode ? {id: activeInputNode.id} : 'NOT FOUND');
                        if (activeInputNode) {
                            if (context.magnodesToCycle) {
                                context.magnodesToCycle.add(sourceNode.id);
                                console.log(`[InstanceNode.getText] Added magnode ${sourceNode.id} to cycle set`);
                            }
                            const text = this.normalize(activeInputNode.text);
                            console.log(`[InstanceNode.getText] Returning text from active input:`, text?.substring(0, 50));
                            return text;
                        }
                    }
                    console.log(`[InstanceNode.getText] No active input found, returning empty`);
                    return '';
                }
                const text = this.normalize(sourceNode.text);
                console.log(`[InstanceNode.getText] Returning text from source:`, text?.substring(0, 50));
                return text;
            }
        }
        
        class NodeManager {
            constructor() {
                this._nodes = []; // Use _nodes internally to work with getter/setter
            }
            
            get nodes() {
                return this._nodes || [];
            }
            
            set nodes(value) {
                this._nodes = value || [];
            }
            
            find(nodeId) {
                return this._nodes.find(n => n.id === nodeId);
            }
            
            create(type, x, y, options = {}) {
                console.log(`[NodeManager.create] Creating ${type} node at (${x}, ${y})`);
                const id = Date.now() + Math.random();
                const pos = { x: x ?? Math.random() * 400 + 50, y: y ?? Math.random() * 300 + 50 };
                
                let node;
                switch(type) {
                    case 'triple': node = new TripleNode(id, pos.x, pos.y, options); break;
                    case 'magnode': node = new MagnodeNode(id, pos.x, pos.y, options); break;
                    case 'instance': node = new InstanceNode(id, pos.x, pos.y, options); break;
                    default: node = new RegularNode(id, pos.x, pos.y, options);
                }
                
                this._nodes.push(node);
                console.log(`[NodeManager.create] Added node to manager, total nodes: ${this._nodes.length}`);
                return node;
            }
            
            add(node) {
                console.log(`[NodeManager.add] Adding node ${node.id} (${node.type})`);
                this._nodes.push(node);
                console.log(`[NodeManager.add] Total nodes: ${this._nodes.length}`);
            }
            
            remove(nodeId) {
                console.log(`[NodeManager.remove] Removing node ${nodeId}`);
                const before = this._nodes.length;
                const index = this._nodes.findIndex(n => n.id === nodeId);
                if (index !== -1) {
                    this._nodes.splice(index, 1);
                }
                console.log(`[NodeManager.remove] Removed, nodes: ${before} -> ${this._nodes.length}`);
            }
        }
        
        class ConnectionManager {
            constructor(connections) {
                this.connections = connections;
            }
            
            find(predicate) {
                return this.connections.find(predicate);
            }
            
            findAll(predicate) {
                return this.connections.filter(predicate);
            }
            
            hasIncoming(nodeId) {
                return this.find(c => c.to === nodeId && (c.inputIndex === undefined || c.inputIndex === null)) !== undefined;
            }
            
            getNodeInputs(nodeId) {
                console.log(`[ConnectionManager.getNodeInputs] Getting inputs for node ${nodeId}`);
                const inputCount = 3;
                const inputs = [[], [], []];
                this.findAll(c => c.to === nodeId && c.inputIndex !== undefined).forEach(conn => {
                    console.log(`[ConnectionManager.getNodeInputs] Found connection:`, {from: conn.from, to: conn.to, inputIndex: conn.inputIndex});
                    if (conn.inputIndex >= 0 && conn.inputIndex < inputCount) {
                        inputs[conn.inputIndex].push(conn.from);
                    }
                });
                console.log(`[ConnectionManager.getNodeInputs] Result:`, inputs);
                return inputs;
            }
            
            getMagnodeInputs(nodeId) {
                console.log(`[ConnectionManager.getMagnodeInputs] Getting inputs for magnode ${nodeId}`);
                const node = nodeManager.find(nodeId);
                if (!node || node.type !== 'magnode') {
                    console.log(`[ConnectionManager.getMagnodeInputs] Node not found or not magnode, returning empty`);
                    return [];
                }
                const inputCount = node.inputCount || 2;
                console.log(`[ConnectionManager.getMagnodeInputs] Input count: ${inputCount}`);
                const inputs = [];
                for (let i = 0; i < inputCount; i++) inputs[i] = [];
                this.findAll(c => c.to === nodeId && c.inputIndex !== undefined).forEach(conn => {
                    console.log(`[ConnectionManager.getMagnodeInputs] Found connection:`, {from: conn.from, to: conn.to, inputIndex: conn.inputIndex});
                    if (conn.inputIndex >= 0 && conn.inputIndex < inputCount) {
                        inputs[conn.inputIndex].push(conn.from);
                    }
                });
                console.log(`[ConnectionManager.getMagnodeInputs] Result:`, inputs);
                return inputs;
            }
            
            getInstanceInputs(nodeId) {
                console.log(`[ConnectionManager.getInstanceInputs] Getting inputs for instance node ${nodeId}`);
                const inputs = [[], []];
                this.findAll(c => c.to === nodeId && c.inputIndex !== undefined).forEach(conn => {
                    console.log(`[ConnectionManager.getInstanceInputs] Found connection:`, {from: conn.from, to: conn.to, inputIndex: conn.inputIndex});
                    if (conn.inputIndex >= 0 && conn.inputIndex < 2) {
                        inputs[conn.inputIndex].push(conn.from);
                    }
                });
                console.log(`[ConnectionManager.getInstanceInputs] Result:`, inputs);
                return inputs;
            }
            
            add(fromId, toId, inputIndex = null) {
                if (this.find(c => c.from === fromId && c.to === toId && c.inputIndex === inputIndex)) {
                    return;
                }
                this.connections.push({ from: fromId, to: toId, inputIndex, waypoints: [] });
            }
            
            remove(fromId, toId, inputIndex = null) {
                console.log(`[ConnectionManager.remove] Removing connection from ${fromId} to ${toId}, inputIndex: ${inputIndex}`);
                const before = this.connections.length;
                
                // Find and remove in place to maintain array reference
                for (let i = this.connections.length - 1; i >= 0; i--) {
                    const c = this.connections[i];
                    if (inputIndex !== null) {
                        if (c.from === fromId && c.to === toId && c.inputIndex === inputIndex) {
                            this.connections.splice(i, 1);
                        }
                    } else {
                        if (c.from === fromId && c.to === toId && (c.inputIndex === undefined || c.inputIndex === null)) {
                            this.connections.splice(i, 1);
                        }
                    }
                }
                
                console.log(`[ConnectionManager.remove] Removed, connections: ${before} -> ${this.connections.length}`);
            }
            
            removeAllForNode(nodeId) {
                console.log(`[ConnectionManager.removeAllForNode] Removing all connections for node ${nodeId}`);
                const before = this.connections.length;
                
                // Remove in place to maintain array reference
                for (let i = this.connections.length - 1; i >= 0; i--) {
                    const c = this.connections[i];
                    if (c.from === nodeId || c.to === nodeId) {
                        this.connections.splice(i, 1);
                    }
                }
                
                console.log(`[ConnectionManager.removeAllForNode] Removed, connections: ${before} -> ${this.connections.length}`);
            }
        }
        
        class ChainBuilder {
            constructor(nodeManager, connectionManager) {
                this.nodeManager = nodeManager;
                this.connectionManager = connectionManager;
                console.log(`[ChainBuilder.constructor] Created ChainBuilder`);
            }
            
            buildFromNode(startNodeId) {
                const visited = new Set();
                const chain = [];
                const magnodeInputsToSkip = new Set(); // Track all non-active magnode inputs
                
                const buildBackwards = (nodeId) => {
                    // FIRST: Check if this node is a non-active magnode input - if so, skip it
                    if (magnodeInputsToSkip.has(nodeId)) {
                        return;
                    }
                    
                    if (visited.has(nodeId)) {
                        return;
                    }
                    visited.add(nodeId);
                    
                    const node = this.nodeManager.find(nodeId);
                    if (!node) {
                        return;
                    }
                    
                    let incomingConnection = null;
                    
                    if (node.type === 'triple') {
                        const inputs = this.connectionManager.getNodeInputs(nodeId);
                        for (let i = 0; i < 3; i++) {
                            if (inputs[i].length > 0) {
                                incomingConnection = this.connectionManager.find(c => c.to === nodeId && c.inputIndex === i);
                                if (incomingConnection) {
                                    break;
                                }
                            }
                        }
                    } else if (node.type === 'magnode') {
                        const magnodeInputs = this.connectionManager.getMagnodeInputs(nodeId);
                        const activeIndex = node.activeIndex || 0;
                        
                        // Mark the magnode itself to skip - it should never be in the chain
                        magnodeInputsToSkip.add(nodeId);
                        
                        // Mark ALL non-active magnode inputs to skip
                        magnodeInputs.forEach((inputArray, idx) => {
                            if (inputArray?.length > 0) {
                                const inputNodeId = inputArray[0];
                                if (idx !== activeIndex) {
                                    magnodeInputsToSkip.add(inputNodeId);
                                    visited.add(inputNodeId); // Also mark as visited so we don't process it
                                }
                            }
                        });
                        
                        if (magnodeInputs[activeIndex]?.length > 0) {
                            const activeInputNodeId = magnodeInputs[activeIndex][0];
                            // Make sure active input is NOT in skip set
                            magnodeInputsToSkip.delete(activeInputNodeId);
                            // Recursively build from the active input instead of the magnode
                            buildBackwards(activeInputNodeId);
                        }
                        // Don't add the magnode itself to the chain
                        return;
                    } else if (node.type === 'instance') {
                        incomingConnection = this.connectionManager.find(c => c.to === nodeId && c.inputIndex === 0);
                    } else {
                        incomingConnection = this.connectionManager.find(c => c.to === nodeId && (c.inputIndex === undefined || c.inputIndex === null));
                    }
                    
                    if (incomingConnection) {
                        buildBackwards(incomingConnection.from);
                    }
                    
                    // Only add node if it's not a non-active magnode input
                    if (!magnodeInputsToSkip.has(nodeId)) {
                        chain.push(node);
                    }
                };
                
                buildBackwards(startNodeId);
                return chain;
            }
        }
        
        class TextExtractor {
            constructor(nodeManager, connectionManager) {
                this.nodeManager = nodeManager;
                this.connectionManager = connectionManager;
                console.log(`[TextExtractor.constructor] Created TextExtractor`);
            }
            
            getNodeText(nodeId, context) {
                console.log(`[TextExtractor.getNodeText] START - Node ${nodeId}`);
                const node = this.nodeManager.find(nodeId);
                if (!node) {
                    console.log(`[TextExtractor.getNodeText] Node not found, returning empty`);
                    return '';
                }
                console.log(`[TextExtractor.getNodeText] Node found:`, {id: node.id, type: node.type});
                const text = node.getText(context);
                console.log(`[TextExtractor.getNodeText] END - Returning text:`, text?.substring(0, 50));
                return text;
            }
            
            getChainText(startNodeId, context) {
                console.log(`[TextExtractor.getChainText] START - Building chain from ${startNodeId}`);
                const chainBuilder = new ChainBuilder(this.nodeManager, this.connectionManager);
                const chain = chainBuilder.buildFromNode(startNodeId);
                const texts = [];
                
                chain.forEach((chainNode, index) => {
                    console.log(`[TextExtractor.getChainText] Processing chain node ${index}:`, {id: chainNode.id, type: chainNode.type});
                    if (chainNode.type === 'magnode') {
                        console.log(`[TextExtractor.getChainText] Skipping magnode in chain`);
                        return;
                    }
                    const nodeText = this.getNodeText(chainNode.id, { ...context, skipMagnodeChain: true });
                    console.log(`[TextExtractor.getChainText] Node text:`, nodeText?.substring(0, 30));
                    if (nodeText) texts.push(nodeText);
                });
                
                const result = texts.join('');
                console.log(`[TextExtractor.getChainText] END - Returning:`, result?.substring(0, 100));
                return result;
            }
        }
        
        class CopyManager {
            constructor(nodeManager, connectionManager, textExtractor) {
                this.nodeManager = nodeManager;
                this.connectionManager = connectionManager;
                this.textExtractor = textExtractor;
                console.log(`[CopyManager.constructor] Created CopyManager`);
            }
            
            copyChain(chain) {
                if (!Array.isArray(chain) || chain.length === 0) return;

                const magnodesToCycle = new Set();
                const processedNodes = new Set();
                const texts = [];

                const ctx = {
                    nodeManager: this.nodeManager,
                    connectionManager: this.connectionManager,
                    textExtractor: this.textExtractor,
                    magnodesToCycle,
                    skipCycling: true
                };

                chain.forEach(node => {
                    if (processedNodes.has(node.id)) return;

                    // Skip non-active magnode inputs, add active parents to cycle
                    const magParents = this.connectionManager.findAll(c => c.from === node.id && c.inputIndex !== undefined);
                    let skip = false;
                    magParents.forEach(conn => {
                        const mag = this.nodeManager.find(conn.to);
                        if (mag?.type === 'magnode') {
                            const active = mag.activeIndex || 0;
                            if (conn.inputIndex === active) {
                                magnodesToCycle.add(mag.id);
                            } else {
                                skip = true;
                            }
                        }
                    });
                    if (skip) {
                        processedNodes.add(node.id);
                        return;
                    }

                    const t = this.textExtractor.getNodeText(node.id, ctx);
                    if (t) {
                        texts.push(t);
                        processedNodes.add(node.id);
                    }
                });

                const concatenationInput = document.getElementById('concatenationInput');
                const prefix = concatenationInput?.value.trim() || '';
                const combinedText = (prefix ? prefix : '') + texts.join('\n');

                navigator.clipboard.writeText(combinedText).then(() => {
                    magnodesToCycle.forEach(id => {
                        const mag = this.nodeManager.find(id);
                        if (mag?.type === 'magnode' && mag.inputCount > 1) {
                            mag.activeIndex = (mag.activeIndex + 1) % mag.inputCount;
                        }
                    });
                    chain.forEach(n => n.copyCount++);
                    totalCopyCount += chain.length;
                    if (chain.length > 0) lastCopiedId = chain[chain.length - 1].id;
                    if (concatenationInput) concatenationInput.value = '';
                    render();
                }).catch(err => {
                    console.error(`[CopyManager.copyChain] ERROR copying:`, err);
                });
            }
            
            copyNode(nodeId) {
                console.log(`[CopyManager.copyNode] ========== START - Node ${nodeId} ==========`);
                const node = this.nodeManager.find(nodeId);
                if (!node) {
                    console.log(`[CopyManager.copyNode] Node not found, returning`);
                    return;
                }
                console.log(`[CopyManager.copyNode] Node found:`, {id: node.id, type: node.type});
                
                const magnodesToCycle = new Set();
                const context = {
                    nodeManager: this.nodeManager,
                    connectionManager: this.connectionManager,
                    textExtractor: this.textExtractor,
                    magnodesToCycle,
                    skipCycling: true
                };
                
                console.log(`[CopyManager.copyNode] Getting text for node`);
                let textToCopy = this.textExtractor.getNodeText(nodeId, context);
                console.log(`[CopyManager.copyNode] Text result:`, textToCopy?.substring(0, 50));
                
                const concatenationInput = document.getElementById('concatenationInput');
                const concatenationText = concatenationInput?.value.trim() || '';
                if (concatenationText) {
                    textToCopy = concatenationText + textToCopy;
                    console.log(`[CopyManager.copyNode] Added concatenation text`);
                }
                
                navigator.clipboard.writeText(textToCopy).then(() => {
                    console.log(`[CopyManager.copyNode] Text copied, cycling magnodes:`, Array.from(magnodesToCycle));
                    magnodesToCycle.forEach(magnodeId => {
                        const magnode = this.nodeManager.find(magnodeId);
                        if (magnode?.type === 'magnode') {
                            const oldIndex = magnode.activeIndex;
                            magnode.cycle();
                            console.log(`[CopyManager.copyNode] Cycled magnode ${magnodeId} from ${oldIndex} to ${magnode.activeIndex}`);
                        }
                    });
                    
                    node.copyCount++;
                    console.log(`[CopyManager.copyNode] ========== END ==========\n`);
                    render();
                }).catch(err => {
                    console.error(`[CopyManager.copyNode] ERROR copying:`, err);
                });
            }
        }
        
        // ============================================================================
        // GLOBAL STATE
        // ============================================================================
        
        const nodeManager = new NodeManager();
        let connections = [];
        const connectionManager = new ConnectionManager(connections);
        const textExtractor = new TextExtractor(nodeManager, connectionManager);
        const copyManager = new CopyManager(nodeManager, connectionManager, textExtractor);
        const chainBuilder = new ChainBuilder(nodeManager, connectionManager);
        
        // Keep nodes array in sync with nodeManager.nodes
        // The getter returns this._nodes, so nodes will always reference the same array
        let nodes = nodeManager.nodes; // This creates a reference to the same array as nodeManager._nodes
        let totalCopyCount = 0;
        let lastCopiedId = null;
        let connectingFrom = null;
        let connectingFromInputIndex = null;
        let connectingTo = null;
        let connectingToInputIndex = null;
        let filename = '';
        let mouseX = 0;
        let mouseY = 0;

        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function normalizeText(text) {
            return text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
        }

        function findNode(nodeId) {
            return nodeManager.find(nodeId);
        }

        function findConnection(predicate) {
            return connectionManager.find(predicate);
        }

        function findConnections(predicate) {
            return connectionManager.findAll(predicate);
        }

        function createNodeId() {
            return Date.now() + Math.random();
        }

        function getRandomPosition(x = null, y = null) {
            return {
                x: x !== null ? x : Math.random() * 400 + 50,
                y: y !== null ? y : Math.random() * 300 + 50
            };
        }

        function createConnectionPath(x1, y1, x2, y2, waypoints = []) {
            if (waypoints.length === 0) {
                // No waypoints: use original curved path
            const dx = Math.abs(x2 - x1);
            const controlOffset = Math.min(dx * 0.5, 100);
            const cp1x = x1 + (x2 > x1 ? controlOffset : -controlOffset);
            const cp1y = y1;
            const cp2x = x2 - (x2 > x1 ? controlOffset : -controlOffset);
            const cp2y = y2;
            return `M ${x1} ${y1} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
            } else {
                // With waypoints: create path through all waypoints
                let path = `M ${x1} ${y1}`;
                let prevX = x1;
                let prevY = y1;
                
                waypoints.forEach((wp, index) => {
                    const dx = Math.abs(wp.x - prevX);
                    const controlOffset = Math.min(dx * 0.5, 100);
                    const cp1x = prevX + (wp.x > prevX ? controlOffset : -controlOffset);
                    const cp1y = prevY;
                    const cp2x = wp.x - (wp.x > prevX ? controlOffset : -controlOffset);
                    const cp2y = wp.y;
                    path += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${wp.x} ${wp.y}`;
                    prevX = wp.x;
                    prevY = wp.y;
                });
                
                // Final segment to destination
                const dx = Math.abs(x2 - prevX);
                const controlOffset = Math.min(dx * 0.5, 100);
                const cp1x = prevX + (x2 > prevX ? controlOffset : -controlOffset);
                const cp1y = prevY;
                const cp2x = x2 - (x2 > prevX ? controlOffset : -controlOffset);
                const cp2y = y2;
                path += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
                
                return path;
            }
        }

        function getConnectorPosition(connector, containerRect) {
            const rect = connector.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2 - containerRect.left,
                y: rect.top + rect.height / 2 - containerRect.top
            };
        }

        // ============================================================================
        // NODE CREATION
        // ============================================================================
        
        function createNode(type, options = {}) {
            return nodeManager.create(type, options.x, options.y, options);
        }

        function addNode(x = null, y = null) {
            nodeManager.create('regular', x, y, {});
            render();
        }

        function addTripleNode(x = null, y = null) {
            nodeManager.create('triple', x, y, { title: 'Triple Node' });
            render();
        }

        function addMagnode(x = null, y = null) {
            nodeManager.create('magnode', x, y, { title: 'Magnode' });
            render();
        }

        function addInstanceNode(x = null, y = null) {
            nodeManager.create('instance', x, y, { title: 'Instance Node' });
            render();
        }

        function buildPromptChainText(startNodeId) {
            const chain = buildChainFromNode(startNodeId);
            const parts = [];
            
            chain.forEach(chainNode => {
                if (chainNode.type === 'magnode') {
                    // Get the active input text
                    const inputs = getMagnodeInputs(chainNode.id);
                    const activeIndex = chainNode.activeIndex || 0;
                    if (inputs[activeIndex] && inputs[activeIndex].length > 0) {
                        const sourceNodeId = inputs[activeIndex][0];
                        const sourceNode = findNode(sourceNodeId);
                        if (sourceNode) {
                            parts.push(normalizeText(sourceNode.text));
                        }
                    }
                } else {
                    // Regular node - get its text
                    const nodeText = normalizeText(chainNode.text);
                    if (nodeText) {
                        parts.push(nodeText);
                    }
                }
            });
            
            return parts.join('\n\n');
        }

        function addStage1Generator(x = null, y = null) {
            // Use saved layout positions for optimal readability
            const baseX = x !== null ? x : 92.38851996487745;
            const baseY = y !== null ? y : 164.23041934490902;
            
            // Create "give me" node
            const giveMeNode = createNode('regular', { 
                x: baseX, 
                y: baseY, 
                title: 'Give me',
                text: 'give me'
            });
            
            // Create count node
            const countNode = createNode('regular', { 
                x: baseX + 380, 
                y: baseY - 8, 
                title: 'Count',
                text: '10'
            });
            
            // Create "companies that do" node
            const companiesNode = createNode('regular', { 
                x: baseX + 726, 
                y: baseY + 4, 
                title: 'Companies that do',
                text: 'companies that do'
            });
            
            // Create virtue node (source, not in chain) - positioned below
            const virtueNode = createNode('regular', { 
                x: baseX + 44, 
                y: baseY + 316, 
                title: 'Virtue',
                text: 'transparency'
            });
            
            // Create "well" text node
            const wellNode = createNode('regular', { 
                x: baseX + 440, 
                y: baseY + 444, 
                title: 'Well',
                text: 'well'
            });
            
            // Create "poorly" text node
            const poorlyNode = createNode('regular', { 
                x: baseX + 422, 
                y: baseY + 668, 
                title: 'Poorly',
                text: 'poorly'
            });
            
            // Create magnode (for switching well/poorly)
            const magnode = createNode('magnode', { 
                x: baseX + 862, 
                y: baseY + 410, 
                title: 'Well/Poorly Switch'
            });
            
            // Create instance node for virtue (first use in chain)
            const virtueInstance1 = createNode('instance', { 
                x: baseX + 1132, 
                y: baseY + 2, 
                title: 'Virtue Instance'
            });
            
            // Create instance node for well/poorly
            const wellPoorlyInstance = createNode('instance', { 
                x: baseX + 1472, 
                y: baseY + 8, 
                title: 'Well/Poorly Instance'
            });
            
            // Create "Provide..." node
            const provideNode = createNode('regular', { 
                x: baseX + 1826, 
                y: baseY + 8, 
                title: 'Provide',
                text: 'Provide:\n\nCompany name\n\nAnd a brief blurb explaining how they do'
            });
            
            // Create instance node for virtue (second use)
            const virtueInstance2 = createNode('instance', { 
                x: baseX + 2180, 
                y: baseY + 12, 
                title: 'Virtue Instance'
            });
            
            // Create instance node for well/poorly (second use)
            const wellPoorlyInstance2 = createNode('instance', { 
                x: baseX + 2504, 
                y: baseY + 26, 
                title: 'Well/Poorly Instance'
            });
            
            // Create era context node
            const eraNode = createNode('regular', { 
                x: baseX + 2840, 
                y: baseY + 24, 
                title: 'Era context',
                text: 'and in what era/context this occurred.'
            });
            
            // Connect nodes in sequence: give me -> count -> companies -> virtueInstance1 -> wellPoorlyInstance -> provide -> virtueInstance2 -> wellPoorlyInstance2 -> era
            addConnection(giveMeNode.id, countNode.id);
            addConnection(countNode.id, companiesNode.id);
            addConnection(companiesNode.id, virtueInstance1.id, 0); // Chain input
            addConnection(virtueInstance1.id, wellPoorlyInstance.id, 0); // Chain input
            addConnection(wellPoorlyInstance.id, provideNode.id);
            addConnection(provideNode.id, virtueInstance2.id, 0); // Chain input
            addConnection(virtueInstance2.id, wellPoorlyInstance2.id, 0); // Chain input
            addConnection(wellPoorlyInstance2.id, eraNode.id);
            
            // Connect virtue node to both instance nodes' content references (input 1)
            addConnection(virtueNode.id, virtueInstance1.id, 1);
            addConnection(virtueNode.id, virtueInstance2.id, 1);
            
            // Connect magnode to both well/poorly instance nodes' content references (input 1)
            addConnection(magnode.id, wellPoorlyInstance.id, 1);
            addConnection(magnode.id, wellPoorlyInstance2.id, 1);
            
            // Connect well and poorly to magnode as inputs
            addConnection(wellNode.id, magnode.id, 0);
            addConnection(poorlyNode.id, magnode.id, 1);
            
            render();
        }

        function addStage2Generator(x = null, y = null) {
            // Use a readable layout position
            const baseX = x !== null ? x : 92.38851996487745;
            const baseY = y !== null ? y : 400;
            
            // Create "Did" node (first in chain)
            const didNode = createNode('regular', { 
                x: baseX, 
                y: baseY, 
                title: 'Did',
                text: 'Did'
            });
            
            // Create company magnode (separate, not in chain, for cycling companies)
            const companyMagnode = createNode('magnode', { 
                x: baseX + 200, 
                y: baseY + 200, 
                title: 'Company Magnode'
            });
            
            // Create instance node for company (in chain, references magnode)
            const companyInstance = createNode('instance', { 
                x: baseX + 200, 
                y: baseY, 
                title: 'Company Instance'
            });
            
            // Create "do" node
            const doNode = createNode('regular', { 
                x: baseX + 400, 
                y: baseY, 
                title: 'do',
                text: 'do'
            });
            
            // Create regular node for virtue
            const virtueNode = createNode('regular', { 
                x: baseX + 600, 
                y: baseY, 
                title: 'Virtue',
                text: 'transparency'
            });
            
            // Create regular node for well/poorly
            const wellPoorlyNode = createNode('regular', { 
                x: baseX + 800, 
                y: baseY, 
                title: 'Well/Poorly',
                text: 'well'
            });
            
            // Create "around" node
            const aroundNode = createNode('regular', { 
                x: baseX + 1000, 
                y: baseY, 
                title: 'around',
                text: 'around'
            });
            
            // Create "[timeframe]" node
            const timeframeNode = createNode('regular', { 
                x: baseX + 1200, 
                y: baseY, 
                title: 'Timeframe',
                text: '[timeframe]'
            });
            
            // Create the elaboration prompt node
            const elaborationNode = createNode('regular', { 
                x: baseX + 1400, 
                y: baseY, 
                title: 'Elaboration Prompt',
                text: 'and does this blurb explain it well? If not, rewrite the blurb. From there, please elaborate in a paragraph or two. Do not tell me it does or does not; merely rewrite the blurb as necessary and elaborate on it from reliable sources.'
            });
            
            // Connect nodes in sequence
            addConnection(didNode.id, companyInstance.id, 0); // Chain input
            addConnection(companyInstance.id, doNode.id);
            addConnection(doNode.id, virtueNode.id);
            addConnection(virtueNode.id, wellPoorlyNode.id);
            addConnection(wellPoorlyNode.id, aroundNode.id);
            addConnection(aroundNode.id, timeframeNode.id);
            addConnection(timeframeNode.id, elaborationNode.id);
            
            // Connect company magnode to company instance (content reference)
            addConnection(companyMagnode.id, companyInstance.id, 1);
            
            render();
        }

        function addStage3Generator(x = null, y = null) {
            // Use a readable layout position
            const baseX = x !== null ? x : 92.38851996487745;
            const baseY = y !== null ? y : 600;
            
            // Create "Write a LinkedIn post about how" node (first in chain)
            const writeNode = createNode('regular', { 
                x: baseX, 
                y: baseY, 
                title: 'Write a LinkedIn post about how',
                text: 'Write a LinkedIn post about how'
            });
            
            // Create company magnode (separate, not in chain, for cycling companies)
            const companyMagnode = createNode('magnode', { 
                x: baseX + 400, 
                y: baseY + 200, 
                title: 'Company Magnode'
            });
            
            // Create instance node for company (in chain, references magnode)
            const companyInstance = createNode('instance', { 
                x: baseX + 400, 
                y: baseY, 
                title: 'Company Instance'
            });
            
            // Create "did" node
            const didNode = createNode('regular', { 
                x: baseX + 720, 
                y: baseY, 
                title: 'did',
                text: 'did'
            });
            
            // Create "respect the principle of" node
            const respectNode = createNode('regular', { 
                x: baseX + 920, 
                y: baseY, 
                title: 'respect the principle of',
                text: 'respect the principle of'
            });
            
            // Create "virtue" node
            const virtueNode = createNode('regular', { 
                x: baseX + 1280, 
                y: baseY, 
                title: 'virtue',
                text: 'virtue'
            });
            
            // Create "and how it affected them." node
            const affectedNode = createNode('regular', { 
                x: baseX + 1480, 
                y: baseY, 
                title: 'and how it affected them.',
                text: 'and how it affected them.'
            });
            
            // Connect nodes in sequence
            addConnection(writeNode.id, companyInstance.id, 0); // Chain input
            addConnection(companyInstance.id, didNode.id);
            addConnection(didNode.id, respectNode.id);
            addConnection(respectNode.id, virtueNode.id);
            addConnection(virtueNode.id, affectedNode.id);
            
            // Connect company magnode to company instance (content reference)
            addConnection(companyMagnode.id, companyInstance.id, 1);
            
            render();
        }

        function addMagnodeInput(nodeId) {
            const node = findNode(nodeId);
            if (node && node.type === 'magnode') {
                const oldInputCount = node.inputCount || 2;
                node.inputCount = oldInputCount + 1;
                const newInputIndex = oldInputCount; // The index of the newly added input
                
                // Create a new regular node to the left of the magnode
                const newNode = createNode('regular', {
                    x: node.x - 320,
                    y: node.y + (newInputIndex * 60), // Stagger vertically for multiple inputs
                    title: '',
                    text: ''
                });
                nodes.push(newNode);
                
                // Connect the new node to the newly created input
                addConnection(newNode.id, nodeId, newInputIndex);
                
                render();
                
                // Focus the new node's textarea
                setTimeout(() => {
                    const newTextarea = document.querySelector(`.node[data-node-id="${newNode.id}"] .blurb-textarea`);
                    if (newTextarea) {
                        newTextarea.focus();
                    }
                }, 0);
            }
        }

        function removeNode(nodeId) {
            nodeManager.remove(nodeId);
            connectionManager.removeAllForNode(nodeId);
            render();
        }

        // ============================================================================
        // NODE UPDATES
        // ============================================================================
        
        function updateNodeProperty(nodeId, property, value) {
            const node = findNode(nodeId);
            if (node) {
                node[property] = value;
            }
        }

        function updateNodeText(nodeId, text) {
            updateNodeProperty(nodeId, 'text', text);
            // If this node is referenced by any instance nodes, trigger a render to update them
            findConnections(c => c.to && findNode(c.to) && findNode(c.to).type === 'instance' && c.inputIndex === 1 && c.from === nodeId).forEach(conn => {
                render();
            });
        }

        function cycleMagnode(nodeId) {
            const node = findNode(nodeId);
            if (node && node.type === 'magnode') {
                const inputCount = node.inputCount || 2;
                node.activeIndex = ((node.activeIndex || 0) + 1) % inputCount;
                // Trigger render to update instance nodes that reference this magnode
                render();
            }
        }

        function updateNodeTitle(nodeId, title) {
            updateNodeProperty(nodeId, 'title', title.trim() || '');
        }

        function updateNodeAllowSplit(nodeId, allowSplit) {
            updateNodeProperty(nodeId, 'allowSplit', allowSplit);
        }

        function cycleTripleNodeSkip(nodeId) {
            const node = findNode(nodeId);
            if (node && node.type === 'triple') {
                node.skipIndex = ((node.skipIndex || 0) + 1) % 3;
            render();
            }
        }

        function separateNode(nodeId) {
            const node = findNode(nodeId);
            if (!node) return;

            const nodeElement = document.querySelector(`.node[data-node-id="${nodeId}"]`);
            if (!nodeElement) return;

            const textarea = nodeElement.querySelector('.blurb-textarea');
            if (!textarea) return;

            const cursorPos = textarea.selectionStart;
            const text = textarea.value;
            const textBefore = text.substring(0, cursorPos);
            const textAfter = text.substring(cursorPos);

            node.text = textBefore;

            const newNode = createNode('regular', {
                x: node.x + 320,
                y: node.y,
                text: textAfter,
                title: '',
                allowSplit: node.allowSplit
            });

            // If this node feeds a magnode input, connect the new node to the next input (if available) without disturbing existing links
            const magConns = findConnections(c => c.from === nodeId && c.inputIndex !== undefined && c.inputIndex !== null);
            magConns.forEach(conn => {
                const mag = findNode(conn.to);
                if (!mag || mag.type !== 'magnode') return;
                const nextIndex = (conn.inputIndex || 0) + 1;
                // Ensure the magnode has enough input slots; expand if needed
                if ((mag.inputCount || 2) <= nextIndex) {
                    mag.inputCount = nextIndex + 1;
                }
                const occupied = findConnection(c => c.to === mag.id && c.inputIndex === nextIndex);
                if (!occupied) addConnection(newNode.id, mag.id, nextIndex);
            });

            render();

            setTimeout(() => {
                const newTextarea = document.querySelector(`.node[data-node-id="${newNode.id}"] .blurb-textarea`);
                if (newTextarea) {
                    newTextarea.focus();
                    newTextarea.setSelectionRange(0, 0);
                }
            }, 0);
        }

        // ============================================================================
        // CONNECTION MANAGEMENT
        // ============================================================================
        
        function getNodeInputs(nodeId) {
            return connectionManager.getNodeInputs(nodeId);
        }

        function getMagnodeInputs(nodeId) {
            return connectionManager.getMagnodeInputs(nodeId);
        }

        function getInstanceInputs(nodeId) {
            return connectionManager.getInstanceInputs(nodeId);
        }

        function getIncomingConnection(nodeId, inputIndex = null) {
            if (inputIndex !== null) {
                return findConnection(c => c.to === nodeId && c.inputIndex === inputIndex);
            }
            return findConnection(c => c.to === nodeId && (c.inputIndex === undefined || c.inputIndex === null));
        }

        function addConnection(fromId, toId, inputIndex = null) {
            connectionManager.add(fromId, toId, inputIndex);
        }

        function removeConnection(fromId, toId, inputIndex = null) {
            connectionManager.remove(fromId, toId, inputIndex);
        }

        // ============================================================================
        // CHAIN LOGIC - Core functions for building and processing chains
        // ============================================================================
        
        function buildChainFromNode(startNodeId) {
            return chainBuilder.buildFromNode(startNodeId);
        }
        
        function getNodeText(nodeId, skipMagnodeChain = false, magnodesToCycle = null, skipCycling = false) {
            const context = {
                nodeManager,
                connectionManager,
                textExtractor,
                magnodesToCycle: magnodesToCycle || new Set(),
                skipCycling,
                skipMagnodeChain
            };
            return textExtractor.getNodeText(nodeId, context);
        }
        
        
        function getChainText(startNodeId, magnodesToCycle = null, skipCycling = false) {
            const context = {
                nodeManager,
                connectionManager,
                textExtractor,
                magnodesToCycle: magnodesToCycle || new Set(),
                skipCycling,
                skipMagnodeChain: true
            };
            return textExtractor.getChainText(startNodeId, context);
        }
        
        function cycleMagnodes(magnodesToCycle) {
            magnodesToCycle.forEach(magnodeId => {
                const magnode = findNode(magnodeId);
                if (magnode && magnode.type === 'magnode') {
                    const inputCount = magnode.inputCount || 2;
                    // Only cycle if there are at least 2 inputs
                    if (inputCount > 1) {
                        magnode.activeIndex = ((magnode.activeIndex || 0) + 1) % inputCount;
                    }
                }
            });
        }

        // ============================================================================
        // COPY FUNCTIONS
        // ============================================================================
        
        function copyToClipboard(nodeId) {
            const node = findNode(nodeId);
            if (!node) return;

            // Create a Set to track magnodes that need cycling (but don't cycle yet)
            const magnodesToCycle = new Set();
            // First pass: collect text without cycling
            let textToCopy = getNodeText(nodeId, false, magnodesToCycle, true);
            const concatenationInput = document.getElementById('concatenationInput');
            const concatenationText = concatenationInput ? concatenationInput.value.trim() : '';
            
            if (concatenationText) {
                textToCopy = concatenationText + textToCopy;
            }

            navigator.clipboard.writeText(textToCopy).then(() => {
                // Second pass: cycle all magnodes after copying
                cycleMagnodes(magnodesToCycle);
                
                node.copyCount++;
                totalCopyCount++;
                lastCopiedId = nodeId;
                updateCopyButton(nodeId);
                
                if (concatenationInput) {
                    concatenationInput.value = '';
                }
                
                render();
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            });
        }

        function cycleCopy() {
            if (nodes.length === 0) return;

            let nextNode = null;
            if (lastCopiedId !== null) {
                const currentIndex = nodes.findIndex(n => n.id === lastCopiedId);
                if (currentIndex !== -1) {
                    const nextIndex = (currentIndex + 1) % nodes.length;
                    nextNode = nodes[nextIndex];
                } else {
                    nextNode = nodes[0];
                }
            } else {
                nextNode = nodes[0];
            }

            if (nextNode) {
                copyToClipboard(nextNode.id);
            }
        }

        function updateCopyButton(id) {
            const nodeElement = document.querySelector(`.node[data-node-id="${id}"]`);
            if (nodeElement) {
                const button = nodeElement.querySelector('.btn-copy');
                if (button) {
                    button.classList.add('copied');
                    button.textContent = 'Copied!';
                    setTimeout(() => {
                        button.classList.remove('copied');
                        button.textContent = 'Copy';
                    }, 2000);
                }
            }
        }

        function getAllChains() {
            const chains = [];
            const processedEndNodes = new Set();
            
            // Find all end nodes (nodes with no outgoing chain connections)
            const endNodes = nodes.filter(node => {
                // Check for regular chain connections (no inputIndex) - these are chain connections
            const hasOutgoingChain = connectionManager.findAll(c => c.from === node.id && (c.inputIndex === undefined || c.inputIndex === null)).length > 0;
                // Check for instance node chain connections (inputIndex 0) - these are also chain connections
                const hasOutgoingInstanceChain = connectionManager.findAll(c => c.from === node.id && c.inputIndex === 0).length > 0;
                
                return !hasOutgoingChain && !hasOutgoingInstanceChain;
            });

            // Build chains backwards from each end node using the proper chain builder
            endNodes.forEach(endNode => {
                if (processedEndNodes.has(endNode.id)) return;
                
                const chain = chainBuilder.buildFromNode(endNode.id);
                if (chain.length > 0) {
                    chains.push(chain);
                    // Mark all nodes in this chain as processed
                    chain.forEach(node => processedEndNodes.add(node.id));
                }
            });

            // Handle any isolated nodes (nodes not in any chain)
            nodes.forEach(node => {
                if (!processedEndNodes.has(node.id)) {
                    // Check if it's a magnode input that's not active - skip it
                    const magnodeConnections = connectionManager.findAll(c => c.from === node.id && c.inputIndex !== undefined);
                    let isNonActiveMagnodeInput = false;
                    magnodeConnections.forEach(conn => {
                        const magnode = nodeManager.find(conn.to);
                        if (magnode?.type === 'magnode') {
                            const activeIndex = magnode.activeIndex || 0;
                            if (conn.inputIndex !== activeIndex) {
                                isNonActiveMagnodeInput = true;
                            }
                        }
                    });
                    
                    if (!isNonActiveMagnodeInput) {
                        chains.push([node]);
                    }
                }
            });

            return chains;
        }

        function copyChain(chain) {
            // Delegate to the new OOP CopyManager which has all the proper logic
            console.log(`[copyChain] Delegating to copyManager.copyChain`);
            copyManager.copyChain(chain);
        }

        // Rebuild chain at click time to avoid stale button-captured arrays
        function copyChainFromNode(nodeId) {
            const chain = chainBuilder.buildFromNode(nodeId);
            copyChain(chain);
        }

        // ============================================================================
        // RENDERING
        // ============================================================================
        
        function calculateTotalCount() {
            return nodes.reduce((sum, node) => sum + node.copyCount, 0);
        }

        function renderNodeConnectors(node, isTriple, isMagnode, isInstance) {
            let html = '';
            
            if (isTriple) {
                const inputs = getNodeInputs(node.id);
                const skipIndex = node.skipIndex || 0;
                for (let i = 0; i < 3; i++) {
                    const hasInput = inputs[i].length > 0;
                    const isSkipped = i === skipIndex;
                    html += `
                        <div class="connector connector-in triple ${hasInput ? 'connected' : ''} ${isSkipped ? 'skipped' : ''}" 
                             data-connector-type="in" 
                             data-node-id="${node.id}"
                             data-input-index="${i}"
                             title="Input ${i + 1}${isSkipped ? ' (skipped)' : ''} - drag to connect"></div>
                    `;
                }
            } else if (isMagnode) {
                const magnodeInputs = getMagnodeInputs(node.id);
                const activeIndex = node.activeIndex || 0;
                const inputCount = node.inputCount || 2;
                for (let i = 0; i < inputCount; i++) {
                    const hasInput = magnodeInputs[i] && magnodeInputs[i].length > 0;
                    const isActive = i === activeIndex;
                    html += `
                        <div class="connector connector-in triple ${hasInput ? 'connected' : ''} ${isActive ? 'active' : ''}" 
                             data-connector-type="in" 
                             data-node-id="${node.id}"
                             data-input-index="${i}"
                             title="Input ${i + 1}${isActive ? ' (active)' : ''} - drag to connect"></div>
                    `;
                }
            } else if (isInstance) {
                const instanceInputs = getInstanceInputs(node.id);
                html += `
                    <div class="connector connector-in triple ${instanceInputs[1] && instanceInputs[1].length > 0 ? 'connected' : ''}" 
                         data-connector-type="in" 
                         data-node-id="${node.id}"
                         data-input-index="1"
                         title="Top-right input: content reference (replaces text box)"></div>
                    <div class="connector connector-in triple ${instanceInputs[0] && instanceInputs[0].length > 0 ? 'connected' : ''}" 
                         data-connector-type="in" 
                         data-node-id="${node.id}"
                         data-input-index="0"
                         title="Bottom-right input: chain input"></div>
                `;
            } else {
                const hasIncoming = findConnection(c => c.to === node.id && (c.inputIndex === undefined || c.inputIndex === null));
                html = `
                    <div class="connector connector-in ${hasIncoming ? 'connected' : ''}" 
                         data-connector-type="in" 
                         data-node-id="${node.id}"
                         title="Input connector - drag to connect"></div>
                `;
            }
            
            return html;
        }

        function renderNodeActions(node, isTriple, isMagnode, isInstance, copyButtonClass, activeIndex) {
            if (isInstance) {
                return `
                    <div style="display: flex; gap: 6px;">
                        <button class="${copyButtonClass}" onclick="copyToClipboard(${node.id})">Copy</button>
                    </div>
                `;
            } else if (!isTriple && !isMagnode) {
                return `
                    <div style="display: flex; gap: 6px;">
                        <button class="btn-separate" onclick="separateNode(${node.id})" title="Split this node at cursor position">Separate Node</button>
                        <button class="${copyButtonClass}" onclick="copyToClipboard(${node.id})">Copy</button>
                    </div>
                `;
            } else if (isTriple) {
                const skipIndex = node.skipIndex || 0;
                return `
                    <div style="display: flex; flex-direction: column; gap: 6px; width: 100%;">
                        <button class="btn-cycle" onclick="cycleTripleNodeSkip(${node.id})" style="width: 100%; padding: 6px 12px; font-size: 11px;" title="Cycle which input is skipped (currently: ${skipIndex + 1})">Cycle Skip (${skipIndex + 1})</button>
                        <button class="${copyButtonClass}" onclick="copyToClipboard(${node.id})" style="width: 100%;">Copy (2 of 3)</button>
                    </div>
                `;
            } else {
                const inputCount = node.inputCount || 2;
                const nextIndex = ((activeIndex || 0) + 1) % inputCount;
                return `
                    <div style="display: flex; flex-direction: column; gap: 6px; width: 100%;">
                        <button class="btn-cycle" onclick="cycleMagnode(${node.id})" style="width: 100%; padding: 6px 12px; font-size: 11px;" title="Cycle to input ${nextIndex + 1}">Cycle (Input ${activeIndex + 1})</button>
                        <button class="${copyButtonClass}" onclick="copyToClipboard(${node.id})" style="width: 100%;">Copy</button>
                    </div>
                `;
            }
        }

        function render() {
            const container = document.getElementById('nodesContainer');
            const emptyState = document.getElementById('emptyState');
            totalCopyCount = calculateTotalCount();

            document.getElementById('totalCount').textContent = totalCopyCount;
            document.getElementById('nodeCount').textContent = nodes.length;

            if (nodes.length === 0) {
                emptyState.style.display = 'block';
                container.querySelectorAll('.node').forEach(node => node.remove());
                container.querySelectorAll('.chain-copy-button').forEach(btn => btn.remove());
                updateConnections();
                return;
            }

            emptyState.style.display = 'none';
            container.querySelectorAll('.node').forEach(node => node.remove());
            container.querySelectorAll('.chain-copy-button').forEach(btn => btn.remove());

            nodes.forEach(node => {
                const nodeElement = document.createElement('div');
                const isTriple = node.type === 'triple';
                const isMagnode = node.type === 'magnode';
                const isInstance = node.type === 'instance';
                let nodeClass = 'node';
                if (isTriple) nodeClass += ' triple-node';
                if (isMagnode) nodeClass += ' magnode';
                if (isInstance) nodeClass += ' instance-node';
                nodeElement.className = nodeClass;
                nodeElement.dataset.nodeId = node.id;
                nodeElement.style.left = node.x + 'px';
                nodeElement.style.top = node.y + 'px';
                // Ensure nodes are always visible: base z-index 10 + y offset (lower nodes = higher z-index)
                nodeElement.style.zIndex = 10 + Math.floor(node.y / 10);

                const hasOutgoing = findConnection(c => c.from === node.id);
                const copyButtonClass = lastCopiedId === node.id ? 'btn-copy last-copied' : 'btn-copy';
                const activeIndex = isMagnode ? (node.activeIndex || 0) : -1;

                // Get instance node content from reference
                let instanceContent = '';
                if (isInstance) {
                    const inputs = getInstanceInputs(node.id);
                    if (inputs[1] && inputs[1].length > 0) {
                        const refNode = findNode(inputs[1][0]);
                        if (refNode) {
                            // If referencing a magnode, show the active input's text
                            if (refNode.type === 'magnode') {
                                const magnodeInputs = getMagnodeInputs(refNode.id);
                                const activeIndex = refNode.activeIndex || 0;
                                if (magnodeInputs[activeIndex] && magnodeInputs[activeIndex].length > 0) {
                                    const activeInputNode = findNode(magnodeInputs[activeIndex][0]);
                                    if (activeInputNode) {
                                        instanceContent = normalizeText(activeInputNode.text);
                                    }
                                }
                            } else {
                                instanceContent = normalizeText(refNode.text);
                            }
                        }
                    }
                }

                const inputConnectorsHtml = renderNodeConnectors(node, isTriple, isMagnode, isInstance);
                const nodeActionsHtml = renderNodeActions(node, isTriple, isMagnode, isInstance, copyButtonClass, activeIndex);

                nodeElement.innerHTML = `
                    <div class="node-header">
                        <div class="copy-count">Copied: ${node.copyCount}${isTriple ? ` (skip: ${(node.skipIndex || 0) + 1})` : ''}</div>
                        <button class="btn-delete" onclick="removeNode(${node.id})" title="Delete node">Delete</button>
                    </div>
                    ${
                        isInstance
                            ? `
                                <div style="display: flex; align-items: flex-start; gap: 8px;">
                                    <div class="node-content" style="flex: 1;">
                                        <input type="text" class="blurb-title" placeholder="Node title (optional)" value="${escapeHtml(node.title || '')}" oninput="updateNodeTitle(${node.id}, this.value)" />
                                        <div class="instance-placeholder">Content comes from top-right input</div>
                                    </div>
                                    <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 8px;">
                                        <div class="node-connectors-in" style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
                                            ${inputConnectorsHtml}
                                        </div>
                                        <div class="node-connectors-out">
                                            <div class="connector connector-out ${hasOutgoing ? 'connected' : ''}" 
                                                 data-connector-type="out" 
                                                 data-node-id="${node.id}"
                                                 title="Output connector - drag from another node's input to connect"></div>
                                        </div>
                                    </div>
                                </div>
                            `
                            : isMagnode
                            ? `
                                <div style="display: flex; align-items: flex-start; gap: 8px;">
                                    <div class="node-connectors-in" style="display: flex; flex-direction: column; align-items: flex-start; gap: 4px;">
                                        ${inputConnectorsHtml}
                                        <button class="btn-add-input" onclick="addMagnodeInput(${node.id})" title="Add another input">+ Add Input</button>
                                    </div>
                                    <div class="node-content" style="flex: 1;">
                                        <input type="text" class="blurb-title" placeholder="Node title (optional)" value="${escapeHtml(node.title || '')}" oninput="updateNodeTitle(${node.id}, this.value)" />
                                        <textarea class="blurb-textarea" placeholder="Magnode - outputs one input at a time" oninput="updateNodeText(${node.id}, this.value)" readonly>${escapeHtml(node.text)}</textarea>
                                    </div>
                                    <div class="node-connectors-out">
                                        <div class="connector connector-out ${hasOutgoing ? 'connected' : ''}" 
                                             data-connector-type="out" 
                                             data-node-id="${node.id}"
                                             title="Output connector - drag from another node's input to connect"></div>
                                    </div>
                                </div>
                            `
                            : `
                                <div style="display: flex; align-items: flex-start; gap: 8px;">
                                    <div class="node-connectors-in" style="${isTriple ? 'display: flex; flex-direction: column; align-items: flex-start; gap: 4px;' : ''}">
                                        ${inputConnectorsHtml}
                                    </div>
                                    <div class="node-content" style="flex: 1;">
                                        <input type="text" class="blurb-title" placeholder="Node title (optional)" value="${escapeHtml(node.title || '')}" oninput="updateNodeTitle(${node.id}, this.value)" />
                                        <textarea class="blurb-textarea" placeholder="${isTriple ? 'Triple node - connects to 3 inputs' : 'Enter your text here...'}" oninput="updateNodeText(${node.id}, this.value)" ${isTriple ? 'readonly' : ''}>${escapeHtml(node.text)}</textarea>
                                    </div>
                                    <div class="node-connectors-out">
                                        <div class="connector connector-out ${hasOutgoing ? 'connected' : ''}" 
                                             data-connector-type="out" 
                                             data-node-id="${node.id}"
                                             title="Output connector - drag from another node's input to connect"></div>
                                    </div>
                                </div>
                            `
                    }
                    <div class="node-actions">
                        ${nodeActionsHtml}
                    </div>
                `;

                makeNodeDraggable(nodeElement, node);
                attachConnectorHandlers(nodeElement, node, isTriple, isMagnode, isInstance);

                if (!isTriple && !isMagnode && !isInstance) {
                    const textarea = nodeElement.querySelector('.blurb-textarea');
                    if (textarea) {
                        textarea.dataset.nodeId = node.id;
                    }
                }

                container.appendChild(nodeElement);
            });

            renderChainButtons();
            updateConnections();
            setupWaypointHandlers();
            updateContainerSize();
        }

        function updateContainerSize() {
            const container = document.getElementById('nodesContainer');
            if (nodes.length === 0) {
                container.style.height = 'auto';
                return;
            }

            // Find the maximum x and y positions of all nodes
            let maxX = 0;
            let maxY = 0;
            nodes.forEach(node => {
                const nodeElement = document.querySelector(`.node[data-node-id="${node.id}"]`);
                if (nodeElement) {
                    const rect = nodeElement.getBoundingClientRect();
                    maxX = Math.max(maxX, node.x + rect.width);
                    maxY = Math.max(maxY, node.y + rect.height);
                } else {
                    // Fallback if element not found yet
                    maxX = Math.max(maxX, node.x + 300);
                    maxY = Math.max(maxY, node.y + 200);
                }
            });

            // Set container height to accommodate all nodes with padding
            const minHeight = Math.max(400, maxY + 100);
            container.style.height = minHeight + 'px';
            
            // Update SVG to match container size
            const svg = document.getElementById('connectionsSvg');
            if (svg) {
                svg.style.width = '100%';
                svg.style.height = '100%';
            }
        }

        function attachConnectorHandlers(nodeElement, node, isTriple, isMagnode, isInstance) {
            let connectorClickStart = null;
            const attachConnectorClick = (connector, nodeId, connectorType, inputIndex = null) => {
                connector.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        connectorClickStart = { x: e.clientX, y: e.clientY, time: Date.now() };
                    }
                });
                
                connector.addEventListener('click', (e) => {
                    // Only create waypoint if it was a simple click (not a drag)
                    if (connectorClickStart) {
                        const dx = Math.abs(e.clientX - connectorClickStart.x);
                        const dy = Math.abs(e.clientY - connectorClickStart.y);
                        const dt = Date.now() - connectorClickStart.time;
                        
                        // Check if connector is connected and it was a simple click (not drag)
                        const isConnected = connector.classList.contains('connected');
                        if (isConnected && dx < 5 && dy < 5 && dt < 300 && !e.shiftKey) {
                            e.stopPropagation();
                            e.preventDefault();
                            createWaypoint(nodeId, connectorType, inputIndex);
                        }
                        connectorClickStart = null;
                    }
                });
            };
            
            if (isTriple) {
                for (let i = 0; i < 3; i++) {
                    const connectorIn = nodeElement.querySelector(`.connector-in[data-input-index="${i}"]`);
                    if (connectorIn) {
                        connectorIn.addEventListener('mousedown', (e) => handleConnectorStart(e, node.id, 'in', i));
                        attachConnectorClick(connectorIn, node.id, 'in', i);
                    }
                }
            } else if (isMagnode) {
                const inputCount = node.inputCount || 2;
                for (let i = 0; i < inputCount; i++) {
                    const connectorIn = nodeElement.querySelector(`.connector-in[data-input-index="${i}"]`);
                    if (connectorIn) {
                        connectorIn.addEventListener('mousedown', (e) => handleConnectorStart(e, node.id, 'in', i));
                        attachConnectorClick(connectorIn, node.id, 'in', i);
                    }
                }
            } else if (isInstance) {
                for (let i = 0; i < 2; i++) {
                    const connectorIn = nodeElement.querySelector(`.connector-in[data-input-index="${i}"]`);
                    if (connectorIn) {
                        connectorIn.addEventListener('mousedown', (e) => handleConnectorStart(e, node.id, 'in', i));
                        attachConnectorClick(connectorIn, node.id, 'in', i);
                    }
                }
                } else {
                const connectorIn = nodeElement.querySelector('.connector-in');
                if (connectorIn) {
                    connectorIn.addEventListener('mousedown', (e) => handleConnectorStart(e, node.id, 'in'));
                    attachConnectorClick(connectorIn, node.id, 'in');
                }
            }
            
            const connectorOut = nodeElement.querySelector('.connector-out');
            if (connectorOut) {
                connectorOut.addEventListener('mousedown', (e) => handleConnectorStart(e, node.id, 'out'));
                attachConnectorClick(connectorOut, node.id, 'out');
            }
        }
        
        function createWaypoint(nodeId, connectorType, inputIndex) {
            const container = document.getElementById('nodesContainer');
            const containerRect = container.getBoundingClientRect();
            
            // Find the connection(s) for this connector
            let matchingConnections = [];
            if (connectorType === 'in') {
                matchingConnections = connections.filter(conn => {
                    if (conn.to !== nodeId) return false;
                    if (inputIndex !== null && inputIndex !== undefined) {
                        return conn.inputIndex === inputIndex;
                    }
                    return conn.inputIndex === undefined || conn.inputIndex === null;
                });
            } else {
                matchingConnections = connections.filter(conn => conn.from === nodeId);
            }
            
            if (matchingConnections.length === 0) return;
            
            // For each matching connection, create a waypoint at the midpoint
            matchingConnections.forEach(conn => {
                const fromNode = findNode(conn.from);
                const toNode = findNode(conn.to);
                if (!fromNode || !toNode) return;
                
                const fromNodeElement = document.querySelector(`.node[data-node-id="${conn.from}"]`);
                const toNodeElement = document.querySelector(`.node[data-node-id="${conn.to}"]`);
                if (!fromNodeElement || !toNodeElement) return;
                
                const fromConnector = fromNodeElement.querySelector('.connector-out');
                let toConnector;
                if ((toNode.type === 'triple' || toNode.type === 'magnode' || toNode.type === 'instance') && conn.inputIndex !== undefined) {
                    toConnector = toNodeElement.querySelector(`.connector-in[data-input-index="${conn.inputIndex}"]`);
                } else {
                    toConnector = toNodeElement.querySelector('.connector-in:not([data-input-index])');
                }
                if (!fromConnector || !toConnector) return;
                
                const fromPos = getConnectorPosition(fromConnector, containerRect);
                const toPos = getConnectorPosition(toConnector, containerRect);
                
                // Initialize waypoints array if it doesn't exist
                if (!conn.waypoints) {
                    conn.waypoints = [];
                }
                
                // Create waypoint at midpoint
                const waypoint = {
                    x: (fromPos.x + toPos.x) / 2,
                    y: (fromPos.y + toPos.y) / 2
                };
                
                conn.waypoints.push(waypoint);
                updateConnections();
            });
        }
        
        function setupWaypointHandlers() {
            const svg = document.getElementById('connectionsSvg');
            if (!svg) return;
            
            // Remove old handlers
            svg.querySelectorAll('.waypoint').forEach(wp => {
                wp.removeEventListener('mousedown', handleWaypointDrag);
                wp.removeEventListener('contextmenu', handleWaypointDelete);
            });
            
            // Add drag handlers for waypoints
            svg.querySelectorAll('.waypoint').forEach(wp => {
                wp.addEventListener('mousedown', handleWaypointDrag);
                wp.addEventListener('contextmenu', handleWaypointDelete);
            });
        }
        
        let draggingWaypoint = null;
        let waypointStartX = 0;
        let waypointStartY = 0;
        
        function handleWaypointDrag(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const connIndex = parseInt(e.target.getAttribute('data-connection-index'));
            const wpIndex = parseInt(e.target.getAttribute('data-waypoint-index'));
            
            if (isNaN(connIndex) || isNaN(wpIndex)) return;
            
            draggingWaypoint = { connIndex, wpIndex };
            const container = document.getElementById('nodesContainer');
            const containerRect = container.getBoundingClientRect();
            waypointStartX = e.clientX - containerRect.left;
            waypointStartY = e.clientY - containerRect.top;
            
            document.addEventListener('mousemove', handleWaypointMove);
            document.addEventListener('mouseup', handleWaypointEnd);
        }
        
        function handleWaypointMove(e) {
            if (!draggingWaypoint) return;
            
            const container = document.getElementById('nodesContainer');
            const containerRect = container.getBoundingClientRect();
            const newX = e.clientX - containerRect.left;
            const newY = e.clientY - containerRect.top;
            
            const conn = connections[draggingWaypoint.connIndex];
            if (conn && conn.waypoints && conn.waypoints[draggingWaypoint.wpIndex]) {
                // Update the waypoint position in the data
                conn.waypoints[draggingWaypoint.wpIndex].x = newX;
                conn.waypoints[draggingWaypoint.wpIndex].y = newY;
                
                // Update the waypoint circle position directly
                const svg = document.getElementById('connectionsSvg');
                const waypointCircle = svg.querySelector(`.waypoint[data-connection-index="${draggingWaypoint.connIndex}"][data-waypoint-index="${draggingWaypoint.wpIndex}"]`);
                if (waypointCircle) {
                    waypointCircle.setAttribute('cx', newX);
                    waypointCircle.setAttribute('cy', newY);
                }
                
                // Update the connection path for this specific connection
                updateSingleConnectionPath(draggingWaypoint.connIndex);
            }
        }
        
        function updateSingleConnectionPath(connIndex) {
            const conn = connections[connIndex];
            if (!conn) return;
            
            const svg = document.getElementById('connectionsSvg');
            const container = document.getElementById('nodesContainer');
            const containerRect = container.getBoundingClientRect();
            
            const fromNode = findNode(conn.from);
            const toNode = findNode(conn.to);
            if (!fromNode || !toNode) return;
            
            const fromNodeElement = document.querySelector(`.node[data-node-id="${conn.from}"]`);
            const toNodeElement = document.querySelector(`.node[data-node-id="${conn.to}"]`);
            if (!fromNodeElement || !toNodeElement) return;
            
            const fromConnector = fromNodeElement.querySelector('.connector-out');
            if (!fromConnector) return;
            
            let toConnector;
            if ((toNode.type === 'triple' || toNode.type === 'magnode' || toNode.type === 'instance') && conn.inputIndex !== undefined) {
                toConnector = toNodeElement.querySelector(`.connector-in[data-input-index="${conn.inputIndex}"]`);
            } else {
                toConnector = toNodeElement.querySelector('.connector-in:not([data-input-index])');
            }
            if (!toConnector) return;
            
            const fromPos = getConnectorPosition(fromConnector, containerRect);
            const toPos = getConnectorPosition(toConnector, containerRect);
            
            const waypoints = (conn.waypoints || []).map(wp => ({ x: wp.x, y: wp.y }));
            
            // Find and update the path for this connection using data attribute
            const path = svg.querySelector(`path.connection-line[data-connection-index="${connIndex}"]`);
            if (path) {
                path.setAttribute('d', createConnectionPath(fromPos.x, fromPos.y, toPos.x, toPos.y, waypoints));
            }
        }
        
        function handleWaypointEnd() {
            draggingWaypoint = null;
            document.removeEventListener('mousemove', handleWaypointMove);
            document.removeEventListener('mouseup', handleWaypointEnd);
        }
        
        function handleWaypointDelete(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const connIndex = parseInt(e.target.getAttribute('data-connection-index'));
            const wpIndex = parseInt(e.target.getAttribute('data-waypoint-index'));
            
            if (isNaN(connIndex) || isNaN(wpIndex)) return;
            
            const conn = connections[connIndex];
            if (conn && conn.waypoints) {
                conn.waypoints.splice(wpIndex, 1);
                updateConnections();
            }
        }

        function renderChainButtons() {
            const container = document.getElementById('nodesContainer');
            // Always remove existing chain buttons first to prevent duplicates
            container.querySelectorAll('.chain-copy-button').forEach(btn => btn.remove());
            
            const chains = getAllChains();
            
            chains.forEach(chain => {
                if (chain.length === 0) return;
                
                const lastNode = chain[chain.length - 1];
                const lastNodeElement = document.querySelector(`.node[data-node-id="${lastNode.id}"]`);
                if (lastNodeElement) {
                    const rect = lastNodeElement.getBoundingClientRect();
                    
                    const button = document.createElement('button');
                    button.className = 'chain-copy-button';
                    button.textContent = 'Copy Chain';
                    // Build the chain fresh at click time to reflect current connections/active inputs
                    button.onclick = () => copyChainFromNode(lastNode.id);
                    button.title = `Copy all ${chain.length} node(s) in this chain`;
                    
                    button.style.left = (lastNode.x + rect.width + 20) + 'px';
                    button.style.top = (lastNode.y + rect.height / 2 - 20) + 'px';
                    
                    container.appendChild(button);
                }
            });
        }

        function makeNodeDraggable(nodeElement, node) {
            let isDragging = false;
            let startX, startY, initialX, initialY;

            nodeElement.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'INPUT' || 
                    e.target.tagName === 'TEXTAREA' || 
                    e.target.tagName === 'BUTTON' ||
                    e.target.closest('.connector')) {
                    return;
                }

                isDragging = true;
                nodeElement.classList.add('dragging');
                startX = e.clientX;
                startY = e.clientY;
                initialX = node.x;
                initialY = node.y;
                                    e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                node.x = initialX + dx;
                node.y = initialY + dy;

                nodeElement.style.left = node.x + 'px';
                nodeElement.style.top = node.y + 'px';
                // Ensure nodes are always visible: base z-index 10 + y offset (lower nodes = higher z-index)
                nodeElement.style.zIndex = 10 + Math.floor(node.y / 10);

                updateConnections();
                renderChainButtons();
                updateContainerSize();
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    nodeElement.classList.remove('dragging');
                }
            });
        }

        // ============================================================================
        // CONNECTION HANDLING
        // ============================================================================
        
        function handleConnectorStart(e, nodeId, type, inputIndex = null) {
            e.stopPropagation();
            e.preventDefault();

            if (type === 'in') {
                connectingFrom = nodeId;
                connectingFromInputIndex = inputIndex;
                connectingTo = null;
                connectingToInputIndex = null;
                
                const existingConnection = getIncomingConnection(nodeId, inputIndex);
                if (existingConnection) {
                    removeConnection(existingConnection.from, nodeId, inputIndex);
                    render();
                    return;
                }

                document.addEventListener('mousemove', handleConnectorMove);
                document.addEventListener('mouseup', handleConnectorEnd);
            }
        }

        function handleConnectorMove(e) {
            if (connectingFrom === null) return;

            const container = document.getElementById('nodesContainer');
            const containerRect = container.getBoundingClientRect();
            const currentMouseX = e.clientX - containerRect.left;
            const currentMouseY = e.clientY - containerRect.top;

            mouseX = currentMouseX;
            mouseY = currentMouseY;

            let closestConnector = null;
            let minDistance = Infinity;
            connectingTo = null;
            connectingToInputIndex = null;

            document.querySelectorAll('.connector-out').forEach(connector => {
                const connectorNodeId = parseFloat(connector.dataset.nodeId);
                if (connectorNodeId === connectingFrom) return;

                const pos = getConnectorPosition(connector, containerRect);
                const distance = Math.sqrt(
                    Math.pow(currentMouseX - pos.x, 2) + Math.pow(currentMouseY - pos.y, 2)
                );

                if (distance < minDistance && distance < 150) {
                    minDistance = distance;
                    closestConnector = connector;
                    connectingTo = connectorNodeId;
                    connectingToInputIndex = null;
                }
            });

            document.querySelectorAll('.connector-out, .connector-in').forEach(conn => {
                conn.classList.remove('connecting');
            });
            if (closestConnector) {
                closestConnector.classList.add('connecting');
            }

            // Draw temporary connection line while dragging
            const svg = document.getElementById('connectionsSvg');
            const existingTempLine = svg.querySelector('.temp-connection-line');
            if (existingTempLine) {
                existingTempLine.remove();
            }

            if (connectingFrom !== null) {
                const fromNodeElement = document.querySelector(`.node[data-node-id="${connectingFrom}"]`);
                if (fromNodeElement) {
                    let fromConnector;
                    if (connectingFromInputIndex !== null && connectingFromInputIndex !== undefined) {
                        fromConnector = fromNodeElement.querySelector(`.connector-in[data-input-index="${connectingFromInputIndex}"]`);
                    } else {
                        fromConnector = fromNodeElement.querySelector('.connector-in:not([data-input-index])');
                    }
                    
                    if (fromConnector) {
                        const fromPos = getConnectorPosition(fromConnector, containerRect);
                        
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('class', 'connection-line temp-connection-line');
                        path.setAttribute('d', `M ${mouseX} ${mouseY} L ${fromPos.x} ${fromPos.y}`);
                        path.setAttribute('stroke', '#ed8936');
                        path.setAttribute('stroke-width', '2');
                        path.setAttribute('fill', 'none');
                        path.setAttribute('stroke-dasharray', '5,5');
                        svg.appendChild(path);
                    }
                }
            }

            updateConnections();
        }

        function handleConnectorEnd(e) {
            console.log(`[handleConnectorEnd] connectingFrom: ${connectingFrom}, connectingTo: ${connectingTo}, inputIndex: ${connectingFromInputIndex}`);
            
            if (connectingFrom !== null && connectingTo !== null) {
                const fromId = connectingTo;
                const toId = connectingFrom;
                const inputIndex = connectingFromInputIndex;
                
                console.log(`[handleConnectorEnd] Creating connection: from ${fromId} to ${toId}, inputIndex: ${inputIndex}`);
                addConnection(fromId, toId, inputIndex);
            } else {
                console.log(`[handleConnectorEnd] Connection failed - one or both endpoints null`);
            }

            connectingFrom = null;
            connectingFromInputIndex = null;
            connectingTo = null;
            connectingToInputIndex = null;

            document.removeEventListener('mousemove', handleConnectorMove);
            document.removeEventListener('mouseup', handleConnectorEnd);

            document.querySelectorAll('.connector-out, .connector-in').forEach(conn => {
                conn.classList.remove('connecting');
            });

            // Remove temporary connection line
            const svg = document.getElementById('connectionsSvg');
            const existingTempLine = svg.querySelector('.temp-connection-line');
            if (existingTempLine) {
                existingTempLine.remove();
            }

            render();
        }

        function updateConnections() {
            const svg = document.getElementById('connectionsSvg');
            const container = document.getElementById('nodesContainer');
            const containerRect = container.getBoundingClientRect();

            svg.innerHTML = '';

            connections.forEach(conn => {
                const fromNode = findNode(conn.from);
                const toNode = findNode(conn.to);
                if (!fromNode || !toNode) return;

                const fromNodeElement = document.querySelector(`.node[data-node-id="${conn.from}"]`);
                const toNodeElement = document.querySelector(`.node[data-node-id="${conn.to}"]`);
                if (!fromNodeElement || !toNodeElement) return;

                const fromConnector = fromNodeElement.querySelector('.connector-out');
                if (!fromConnector) return;

                let toConnector;
                if ((toNode.type === 'triple' || toNode.type === 'magnode' || toNode.type === 'instance') && conn.inputIndex !== undefined) {
                    toConnector = toNodeElement.querySelector(`.connector-in[data-input-index="${conn.inputIndex}"]`);
                } else {
                    toConnector = toNodeElement.querySelector('.connector-in:not([data-input-index])');
                }
                if (!toConnector) return;

                const fromPos = getConnectorPosition(fromConnector, containerRect);
                const toPos = getConnectorPosition(toConnector, containerRect);

                const isSkipped = toNode.type === 'triple' && conn.inputIndex === (toNode.skipIndex || 0);
                const isActive = toNode.type === 'magnode' && conn.inputIndex === (toNode.activeIndex || 0);
                const isChainInput = toNode.type === 'instance' && conn.inputIndex === 0;
                const isConnecting = (connectingFrom === conn.to && connectingTo === conn.from);

                // Get waypoints for this connection (ensure array exists)
                const waypoints = (conn.waypoints || []).map(wp => ({
                    x: wp.x,
                    y: wp.y
                }));

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', `connection-line ${isConnecting ? 'connecting' : ''} ${isSkipped ? 'skipped' : ''} ${isActive ? 'active' : ''} ${isChainInput ? 'active' : ''}`);
                path.setAttribute('data-connection-index', connections.indexOf(conn));
                path.setAttribute('d', createConnectionPath(fromPos.x, fromPos.y, toPos.x, toPos.y, waypoints));
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                svg.appendChild(path);
                
                // Render waypoints for this connection (render after path so they appear on top)
                waypoints.forEach((wp, index) => {
                    const waypointCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    waypointCircle.setAttribute('cx', wp.x);
                    waypointCircle.setAttribute('cy', wp.y);
                    waypointCircle.setAttribute('r', '8');
                    waypointCircle.setAttribute('fill', 'white');
                    waypointCircle.setAttribute('stroke', '#667eea');
                    waypointCircle.setAttribute('stroke-width', '2');
                    waypointCircle.setAttribute('class', 'waypoint');
                    waypointCircle.setAttribute('data-connection-index', connections.indexOf(conn));
                    waypointCircle.setAttribute('data-waypoint-index', index);
                    waypointCircle.setAttribute('style', 'cursor: move; pointer-events: all;');
                    waypointCircle.setAttribute('title', 'Drag to move waypoint, right-click to delete');
                    
                    // Attach drag and delete handlers directly
                    waypointCircle.addEventListener('mousedown', handleWaypointDrag);
                    waypointCircle.addEventListener('contextmenu', handleWaypointDelete);
                    
                    svg.appendChild(waypointCircle);
                });
            });
            
            // Setup waypoint handlers after rendering
            setupWaypointHandlers();

            if (connectingFrom !== null) {
                const fromNodeElement = document.querySelector(`.node[data-node-id="${connectingFrom}"]`);
                if (fromNodeElement) {
                    let fromConnector;
                    if (connectingFromInputIndex !== null) {
                        fromConnector = fromNodeElement.querySelector(`.connector-in[data-input-index="${connectingFromInputIndex}"]`);
                    } else {
                        fromConnector = fromNodeElement.querySelector('.connector-in:not([data-input-index])');
                    }
                    
                    if (fromConnector) {
                        const fromPos = getConnectorPosition(fromConnector, containerRect);
                        let x2 = mouseX, y2 = mouseY;
                        
                        if (connectingTo !== null) {
                            const targetNodeElement = document.querySelector(`.node[data-node-id="${connectingTo}"]`);
                            if (targetNodeElement) {
                                let targetConnector;
                                if (connectingToInputIndex !== null) {
                                    targetConnector = targetNodeElement.querySelector(`.connector-in[data-input-index="${connectingToInputIndex}"]`);
                                } else {
                                    targetConnector = targetNodeElement.querySelector('.connector-out');
                                }
                                
                                if (targetConnector) {
                                    const targetPos = getConnectorPosition(targetConnector, containerRect);
                                    x2 = targetPos.x;
                                    y2 = targetPos.y;
                                }
                            }
                        }

                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('class', 'connection-line connecting');
                        path.setAttribute('d', createConnectionPath(fromPos.x, fromPos.y, x2, y2));
                        path.setAttribute('stroke-linecap', 'round');
                        path.setAttribute('stroke-linejoin', 'round');
                        svg.appendChild(path);
                    }
                }
            }
        }

        // ============================================================================
        // FILE OPERATIONS
        // ============================================================================
        
        function createSaveData() {
            return {
                name: filename || undefined,
                nodes: nodes,
                connections: connections,
                totalCopyCount: totalCopyCount,
                lastCopiedId: lastCopiedId,
                savedAt: new Date().toISOString()
            };
        }

        function saveData() {
            filename = document.getElementById('filenameInput').value.trim();
            const data = createSaveData();
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const defaultName = filename || `copycount-${new Date().toISOString().split('T')[0]}`;
            a.download = `${defaultName}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function saveAsData() {
            filename = document.getElementById('filenameInput').value.trim();

            if ('showSaveFilePicker' in window) {
                try {
                    const data = createSaveData();
                    const json = JSON.stringify(data, null, 2);
                    const blob = new Blob([json], { type: 'application/json' });

                    const defaultName = filename || `copycount-${new Date().toISOString().split('T')[0]}`;
                    const handle = await window.showSaveFilePicker({
                        suggestedName: `${defaultName}.json`,
                        types: [{
                            description: 'JSON Files',
                            accept: {'application/json': ['.json']},
                        }],
                    });

                    const writable = await handle.createWritable();
                    await writable.write(blob);
                    await writable.close();

                    alert('File saved successfully!');
                    return;
                } catch (err) {
                    console.log('File System Access API failed, falling back to download:', err);
                }
            }

            saveData();
        }

        function loadData() {
            document.getElementById('fileInput').click();
        }

        function normalizeLoadedNode(node, index = 0) {
            console.log(`[normalizeLoadedNode] Loading node:`, node);
            const nodeType = node.type || 'regular';
            const nodeId = node.id || Date.now() + Math.random() + index;
            const pos = {
                x: node.x !== undefined ? node.x : Math.random() * 400 + 50,
                y: node.y !== undefined ? node.y : Math.random() * 300 + 50
            };
            
            const options = {
                text: node.text || '',
                title: node.title || '',
                allowSplit: node.allowSplit !== undefined ? node.allowSplit : true
            };
            
            // Create proper node instance using NodeManager
            const nodeInstance = nodeManager.create(nodeType, pos.x, pos.y, options);
            nodeInstance.id = nodeId; // Preserve original ID
            nodeInstance.copyCount = node.copyCount || 0;
            
            // Set type-specific properties
            if (nodeType === 'triple') {
                nodeInstance.skipIndex = node.skipIndex !== undefined ? node.skipIndex : 0;
            } else if (nodeType === 'magnode') {
                nodeInstance.inputCount = node.inputCount !== undefined ? node.inputCount : 2;
                nodeInstance.activeIndex = node.activeIndex !== undefined ? node.activeIndex : 0;
            } else if (nodeType === 'instance') {
                nodeInstance.inputCount = 2;
            }
            
            console.log(`[normalizeLoadedNode] Created ${nodeType} node instance:`, nodeInstance);
            return nodeInstance;
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (data.nodes && Array.isArray(data.nodes)) {
                        console.log(`[handleFileSelect] ========== START LOADING ==========`);
                        console.log(`[handleFileSelect] Loading ${data.nodes.length} nodes`);
                        
                        // Clear existing nodes and keep single source of truth
                        nodeManager.nodes = [];
                        nodes = nodeManager.nodes;
                        
                        // Load nodes (normalizeLoadedNode adds to nodeManager via create)
                        data.nodes.forEach((node, index) => normalizeLoadedNode(node, index));
                        console.log(`[handleFileSelect] Loaded ${nodes.length} nodes into nodeManager`);
                        console.log(`[handleFileSelect] Node IDs:`, nodes.map(n => ({id: n.id, type: n.type})));
                        
                        // Load connections
                        console.log(`[handleFileSelect] Loading ${data.connections?.length || 0} connections`);
                        connections = (data.connections || []).map(conn => {
                            const connObj = {
                                ...conn,
                                waypoints: conn.waypoints || []
                            };
                            console.log(`[handleFileSelect] Loading connection:`, {from: connObj.from, to: connObj.to, inputIndex: connObj.inputIndex});
                            return connObj;
                        });
                        connectionManager.connections = connections;
                        console.log(`[handleFileSelect] Loaded ${connections.length} connections into connectionManager`);
                        console.log(`[handleFileSelect] Connection details:`, connections.map(c => ({from: c.from, to: c.to, inputIndex: c.inputIndex})));
                        console.log(`[handleFileSelect] ========== END LOADING ==========`);
                    } else if (data.columns && Array.isArray(data.columns)) {
                        nodeManager.nodes = [];
                        nodes = nodeManager.nodes;
                        connections = [];
                        let xOffset = 50;
                        data.columns.forEach((column, colIndex) => {
                            column.blurbs.forEach((blurb, blurbIndex) => {
                                const nodeId = blurb.id || createNodeId() + blurbIndex;
                                normalizeLoadedNode({
                                    id: nodeId,
                                    x: xOffset + colIndex * 320,
                                    y: 50 + blurbIndex * 200,
                                text: blurb.text || '',
                                copyCount: blurb.copyCount || 0,
                                    title: blurb.title || '',
                                    allowSplit: blurb.allowSplit
                                }, blurbIndex);
                                
                                if (blurbIndex > 0) {
                                    const prevNodeId = column.blurbs[blurbIndex - 1].id;
                                    if (prevNodeId) {
                                        connections.push({ from: prevNodeId, to: nodeId });
                                    }
                                }
                            });
                        });
                    } else if (data.blurbs && Array.isArray(data.blurbs)) {
                        nodeManager.nodes = [];
                        nodes = nodeManager.nodes;
                        data.blurbs.forEach((blurb, index) => normalizeLoadedNode({
                            ...blurb,
                            x: 50 + (index % 3) * 320,
                            y: 50 + Math.floor(index / 3) * 200
                        }, index));
                        connections = [];
                    } else {
                        alert('Invalid file format');
                        return;
                    }

                    // Always sync connectionManager with latest array
                    connectionManager.connections = connections;

                    if (data.totalCopyCount !== undefined) {
                        totalCopyCount = data.totalCopyCount;
                    }
                    if (data.lastCopiedId !== undefined) {
                        lastCopiedId = data.lastCopiedId;
                    }
                    if (data.name !== undefined) {
                        filename = data.name;
                        document.getElementById('filenameInput').value = filename;
                    }
                    render();
                } catch (err) {
                    console.error('Error loading file:', err);
                    alert('Failed to load file. Please check the file format.');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Track mouse position for connection line
        document.addEventListener('mousemove', (e) => {
            const container = document.getElementById('nodesContainer');
            const containerRect = container.getBoundingClientRect();
            mouseX = e.clientX - containerRect.left;
            mouseY = e.clientY - containerRect.top;
        });

        // Initialize on load
        function init() {
            render();
        }

        init();
    </script>
</body>
</html>